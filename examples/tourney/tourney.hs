{-# LANGUAGE EmptyDataDecls, DeriveGeneric, OverloadedStrings, ScopedTypeVariables #-}

{-|
Module      : Main
Description : The @minimalistic@ HAAP example

This module presents a minimalistic example of the usage of HAAP, consisting on testing an @HSpec@
specification, running several code analysis plugins, providing global feedback with the @ranking@ and
@tournament@ plugins, visualization of solutions with @CodeWorld@, all connected by a webpage
generated by @Hakyll@.
-}
module Main where

import HAAP

import Data.Default
import Data.Binary
import Data.Char
import Data.Monoid hiding ((<>))
import qualified Data.Map as Map
import Data.Unique

import Control.DeepSeq
import Control.Monad.IO.Class

import System.Random.Shuffle
import System.Process

import GHC.Generics (Generic(..))

example :: Project
example = Project
    { projectName = "example"
    , projectPath = "."
    , projectTmpPath = "tmp"
    , projectGroups = []
    , projectTasks = []
    }

emptyExample_DB = Example_DB (HaapTourneyDB 1 [])

data Example_DB = Example_DB
        { exTourneyDB :: HaapTourneyDB ExPlayer }
    deriving (Generic)
instance Binary Example_DB

lnsTourney :: DBLens (BinaryDB Example_DB) (HaapTourneyDB ExPlayer)
lnsTourney = DBLens
    (BinaryDBQuery exTourneyDB)
    (\st -> BinaryDBUpdate $ \db -> ((),db { exTourneyDB = st }) )

{-|
An HAAP script that runs tests with the @HSpec@ plugin, runs several code analysis plugins, generates
feedback with the @ranking@ and @tournament@ plugins, provides visualization with the @CodeWorld@ plugin
and uses the @Hakyll@ plugin to generate a webpage that connects all artifacts.
-}
main = do
    let hakyllArgs = HakyllArgs defaultConfiguration True True True def
    let dbArgs = BinaryDBArgs "db" emptyExample_DB def
    
    -- load the @Hakyll@ and database @DB@ plugins
    runHaap example $ useHakyll hakyllArgs $ useBinaryDB dbArgs $ do
        useRank $ useTourney $ renderHaapTourney exTourney
        
        

data ExPlayer = ExPlayer (String,Bool)
    deriving (Eq,Ord,Show,Generic)
instance Binary ExPlayer
instance NFData ExPlayer

instance Pretty ExPlayer where
    pretty (ExPlayer x) = string (fst x)

instance TourneyPlayer ExPlayer where
    isDefaultPlayer (ExPlayer (_,b)) = b
    defaultPlayer = do
        i <- newUnique
        return $ ExPlayer ("random" ++ show (hashUnique i),True)

exTourney :: MonadIO m => HaapTourney t m (BinaryDB Example_DB) ExPlayer Link
exTourney = HaapTourney
    { tourneyMax = 10
    , tourneyTitle = "Tourney"
    , tourneyNotes = ""
    , tourneyRounds = mkRounds
    , tourneyPlayerTag = "Group"
    , tourneyPlayers = grupos
    , tourneyPath = "torneio"
    , lensTourneyDB = lnsTourney
    , tourneyMatch = match
    , renderMatch = return
    , deleteTourney = const $ return ()
    }
  where
    grupos = Left $ map (ExPlayer . mapFst show) $ zip [1..] (replicate 4 False ++ replicate 10 True)
    match tno rno mno players = do
        return (zip players [1..],"link")
    --mkRounds sz = [TourneyRound 16 4 1 1,TourneyRound 4 4 1 1,TourneyRound 1 1 1 1]
    mkRounds _ = [TourneyRound 128 4 2 1,TourneyRound 64 4 1 1,TourneyRound 16 4 1 1,TourneyRound 4 4 1 1,TourneyRound 1 1 1 1]



